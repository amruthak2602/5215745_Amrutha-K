#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int type;       // 1 = append, 2 = delete
    char *str;      // store appended string or deleted substring
} Operation;

int main() {
    int Q;
    if (scanf("%d", &Q) != 1) return 0;

    // Dynamic string to hold S
    char *S = malloc(1000005 * sizeof(char));
    int len = 0;
    S[0] = '\0';

    // History stack
    Operation *history = malloc(Q * sizeof(Operation));
    int hist_top = -1;

    for (int i = 0; i < Q; i++) {
        int t;
        scanf("%d", &t);

        if (t == 1) {
            // Append
            char W[1000001];
            scanf("%s", W);
            int wlen = strlen(W);

            // Save operation for undo
            hist_top++;
            history[hist_top].type = 1;
            history[hist_top].str = strdup(W);

            // Expand S
            memcpy(S + len, W, wlen + 1);
            len += wlen;

        } else if (t == 2) {
            // Delete last k characters
            int k;
            scanf("%d", &k);

            hist_top++;
            history[hist_top].type = 2;
            history[hist_top].str = malloc((k + 1) * sizeof(char));

            // Copy deleted substring
            memcpy(history[hist_top].str, S + len - k, k);
            history[hist_top].str[k] = '\0';

            // Perform delete
            len -= k;
            S[len] = '\0';

        } else if (t == 3) {
            // Print kth character (1-indexed)
            int k;
            scanf("%d", &k);
            if (k > 0 && k <= len) {
                printf("%c\n", S[k - 1]);
            }

        } else if (t == 4) {
            // Undo last operation
            if (hist_top >= 0) {
                Operation op = history[hist_top--];
                if (op.type == 1) {
                    // Undo append
                    int wlen = strlen(op.str);
                    len -= wlen;
                    S[len] = '\0';
                } else if (op.type == 2) {
                    // Undo delete (re-append)
                    int slen = strlen(op.str);
                    memcpy(S + len, op.str, slen + 1);
                    len += slen;
                }
                free(op.str);
            }
        }
    }

    // Clean up
    for (int i = 0; i <= hist_top; i++) {
        free(history[i].str);
    }
    free(history);
    free(S);

    return 0;
}
